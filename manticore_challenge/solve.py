from manticore import Manticore
from pwn       import log

FILE  = "./manticore_challenge"
DEBUG = False # if True will print debug information

# This function will set hooks on negative branches
# It will speed up incredibly the execution because Manticore will not
# waste computing power on uninteresting code paths
def set_hooks(m, pc):
    neg = pc + 0x5
    @m.hook(neg)
    def hook_exit(state):
        if DEBUG: log.info("Negative branch @ {0}".format(hex(neg)))
        state.abandon()

# Function responsible for setting some static hooks like the one for skipping IO
# or the one for stopping execution once we reach the end of the code
def mantify(m):
    
    # set hook to the instruction right before puts()
    @m.hook(0x555555554aba)
    
    # Overwrite RIP once execution reaches puts() with the address of the instruction right next
    # gets(). This speeds up execution because IO operations overload Manticore and are usually
    # uninteresting when it comes to binary analysis
    def hook_skip_IO(state):
        pc = state.cpu.PC
        addr = state.cpu.RBP-0x14 # fetch address where the input would have been written to
        buff = state.new_symbolic_buffer(11) # create a symbolic buffer value to feed in place of the IO buffer

        if DEBUG: 
            log.info("Skipping IO to speed up the process, jumping from {0} to {1}".format(hex(pc), hex(pc+0x1D)))
            log.info("Writing symbolic buffer @ {0}".format(hex(addr)))

        state.cpu.write_register("RIP", pc+0x1D) # jump from pre-puts() to post-gets()
        state.cpu.write_bytes(addr, buff) # write symbolic buffer to memory
        with m.locked_context() as context:
            context["buffer_addr"] = addr # save buffer address to context

    # hook every instruction to check for specific conditions
    @m.hook(None)
    def hook_instruction(state):
        cpu    = state.cpu
        pc     = cpu.PC
        opcode = cpu.read_int(pc, size=32)

        # Check if the instruction:
        #  - starts with a "cmp bl, ???" [80 fb ??]
        #  - ends with a "jmp ???" [74 ??] (Intel archs are little endian)
        #  - has not been hooked already
        with m.locked_context() as context:
            if ((opcode & 0xFFFF == 0xfb80) and
                (opcode >> 24 & 0xFF == 0x74) and
                (pc not in context["branches"])):

                if DEBUG: log.info("Found branch @ {0}".format(hex(pc)))
                _branches = context["branches"]
                _branches.append(pc)
                context["branches"] = _branches
                set_hooks(m, pc) # call set_hooks on the instruction to avoid negative branches
    
    # hook the instruction of the last positive branch
    @m.hook(0x555555554a95)
    def hook_win(state):
        if DEBUG: log.info("Reached end, solving...")
        with m.locked_context() as context:
            buff = state.cpu.read_bytes(context["buffer_addr"], 11) # read the address of the symbolic buffer
            flag = "".join(chr(state.solve_one(x)) for x in buff) # solve the symbolic values and join them 
            if not DEBUG: p.success("Finished. Flag is: {0}".format(flag)) # print the flag :)
            else: log.success("Flag is: {0}".format(flag))
        m.terminate() # terminate Manticore


if __name__ == "__main__":
    if not DEBUG: 
        p = log.progress("Analysis status")
        p.status("Setting up hooks...")
    m = Manticore(FILE)

    m.context["branches"]     = [] # create an entry in the context that will hold all the branches in the code
    m.context["buffer_addr"]  = [] # create an entry in the context that will hold the address of the input
    
    mantify(m) # analyze and set hooks
    if not DEBUG: p.status("Finished setting up hooks, starting Manticore...")
    m.run() # start Manticore 
